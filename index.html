<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebGL Viewer - Orthographic</title>

    <!-- Helpers downloaded from interactivecomputergraphics.com -->
    <script src="common/initShaders.js"></script>
    <script src="common/MV.js"></script>

    <style>
        body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
        #gl-canvas { border: 1px solid #ccc; display: block; margin-top: 8px; }
        .row { display:flex; align-items:center; gap:8px; }
    </style>
</head>
<body>
    <div class="row">
        <span>depth 0.05</span>
        <input id="depthSlider" type="range" min="0.05" max="20" step="0.1" value="10" />
        <span>3</span>
    </div>

    <canvas id="gl-canvas" width="512" height="512"></canvas>

    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aPosition;
        attribute vec4 aColor;
        varying vec4 vColor;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;

        void main() {
            vColor = aColor;
            gl_Position = uProjectionMatrix * uModelViewMatrix * aPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec4 vColor;
        void main() {
            gl_FragColor = vColor;
        }
    </script>

    <!-- Main JavaScript -->
    <script>
    
    let gl;
    let modelViewMatrixLoc, projectionMatrixLoc;
    let numPositions = 0;
    let radius = 2.2;
    // Added for arcball click and drag function
    let modelRot = mat4();
    
    // Camera (spherical) and view volume
    const at = vec3(0.0, 0.0, 0.0);
    let left = -2.0, right = 2.0, bottom = -2.0, ytop = 2.0, near = -10.0, far = 10.0;

    // Buffers
    let positionBuffer, colorBuffer;

    // --- Geometry: Colored cube (12 triangles) ---
    // 8 cube vertices
    const vertices = [
        vec4(-0.5, -0.5,  0.5, 1.0),  // 0 front-bottom-left
        vec4( 0.5, -0.5,  0.5, 1.0),  // 1 front-bottom-right
        vec4( 0.5,  0.5,  0.5, 1.0),  // 2 front-top-right
        vec4(-0.5,  0.5,  0.5, 1.0),  // 3 front-top-left
        vec4(-0.5, -0.5, -0.5, 1.0),  // 4 back-bottom-left
        vec4( 0.5, -0.5, -0.5, 1.0),  // 5 back-bottom-right
        vec4( 0.5,  0.5, -0.5, 1.0),  // 6 back-top-right
        vec4(-0.5,  0.5, -0.5, 1.0),  // 7 back-top-left
    ];

    // Per-vertex colors
    const baseColors = [
        vec4(1.0, 0.0, 0.0, 1.0), // red
        vec4(0.0, 1.0, 0.0, 1.0), // green
        vec4(0.0, 0.0, 1.0, 1.0), // blue
        vec4(1.0, 1.0, 0.0, 1.0), // yellow
        vec4(1.0, 0.0, 1.0, 1.0), // magenta
        vec4(0.0, 1.0, 1.0, 1.0), // cyan
        vec4(1.0, 0.5, 0.0, 1.0), // orange
        vec4(0.7, 0.7, 0.7, 1.0), // gray
    ];

    const positions = [];
    const colors = [];

    // Push two triangles for a quad
    function quad(a, b, c, d, colorIndex) {
        const col = baseColors[colorIndex % baseColors.length];
        const tri = [a, b, c, a, c, d];
        tri.forEach(i => {
            positions.push(vertices[i]);
            colors.push(col);
        });
    }

    // Faces: +Z (front), +X (right), -Z (back), -X (left), +Y (top), -Y (bottom)
    function buildCube() {
        quad(0, 1, 2, 3, 0); // front
        quad(1, 5, 6, 2, 1); // right
        quad(5, 4, 7, 6, 2); // back
        quad(4, 0, 3, 7, 3); // left
        quad(3, 2, 6, 7, 4); // top
        quad(4, 5, 1, 0, 5); // bottom
        numPositions = positions.length; // vec4s
    }

    // --- Init ---
    window.onload = function init() {
        const canvas = document.getElementById("gl-canvas");
        gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (!gl) { alert("WebGL Not available"); return; }

        // Viewport & clear
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.93, 0.93, 0.95, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);

        // Program
        const program = initShaders(gl, "vertex-shader", "fragment-shader");
        gl.useProgram(program);

        // Build geometry
        buildCube();

        // Position buffer
        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(positions), gl.STATIC_DRAW);
        const aPosition = gl.getAttribLocation(program, "aPosition");
        gl.vertexAttribPointer(aPosition, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aPosition);

        // Color buffer
        colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);
        const aColor = gl.getAttribLocation(program, "aColor");
        gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aColor);

        // Uniform locations
        modelViewMatrixLoc = gl.getUniformLocation(program, "uModelViewMatrix");
        projectionMatrixLoc = gl.getUniformLocation(program, "uProjectionMatrix");

        // Depth slider (live)
        const depthSlider = document.getElementById("depthSlider");
        depthSlider.addEventListener("input", (e) => {
            const v = parseFloat(e.target.value);
            far = v * 0.5;
            near = -v * 0.5;
        });

        // Mouse drag to orbit camera
        attachArcballControls(canvas);

        requestAnimationFrame(render);
    };

    // --- Orbit controls (drag to rotate) ---
    // Added scroll wheel option to make cube larger or smaller
    function attachArcballControls(canvas) {
        let dragging = false;
        let v0 = null; // arcball vector at mouse-down

        const SENS = 1.0;

        function screenToArcball(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            let x = ((clientX - rect.left) / rect.width) * 2 - 1;
            let y = ((clientY - rect.top) / rect.height) * -2 + 1;

            const len2 = x*x + y*y;
            if (len2 <= 1) {
                const z = Math.sqrt(1 - len2);
                return vec3(x, y, z);
            } else {
                const invLen = 1 / Math.sqrt(len2);
                return vec3(x * invLen, y * invLen, 0);
            }
        }

        canvas.style.cursor = 'grab';

        canvas.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            dragging = true;
            v0 = screenToArcball(e.clientX, e.clientY);
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        });

        window.addEventListener('mouseup', () => {
            dragging = false;
            canvas.style.cursor = 'grab';
        });

        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;

            const v1 = screenToArcball(e.clientX, e.clientY);
            const axis = cross(v1, v0);
            const axisLen = Math.hypot(axis[0], axis[1], axis[2]);

            if (axisLen > 1e-6) {
                const dotv = Math.max(-1, Math.min(1, dot(v0, v1)));
                const angleRad = Math.acos(dotv) * SENS;
                const axisNorm = normalize(axis);

                const rot = rotate(angleRad * 180 / Math.PI, axisNorm);
                modelRot = mult(rot, modelRot);
                v0 = v1;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            const k = Math.exp(-e.deltaY * 0.001);
            left *= k; right *= k;
            bottom *= k; ytop *= k;
            e.preventDefault();
        }, { passive: false });
    }

    // --- Render Loop ---
    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // View & projection

        // Added these consts for arcball click and drag
        // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        const eye = vec3(0.0, 0.0, radius);
        const view = lookAt(eye, at, vec3(0, 1, 0));
        const modelViewMatrix = mult(view, modelRot);
        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        const projectionMatrix = ortho(left, right, bottom, ytop, near, far);

        // Upload uniforms
        gl.uniformMatrix4fv(modelViewMatrixLoc, false, flatten(modelViewMatrix));
        gl.uniformMatrix4fv(projectionMatrixLoc, false, flatten(projectionMatrix));

        // Draw the cube
        gl.drawArrays(gl.TRIANGLES, 0, numPositions);

        requestAnimationFrame(render);
    }
    </script>
</body>
</html>