<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebGL Viewer - Orthographic</title>

    <script src="common/initShaders.js"></script>
    <script src="common/MV.js"></script>
    <style>
        body { font-family: system-ui, Arial, sans-serif; margin: 16px; }
        #gl-canvas { border: 1px solid #ccc; display: block; margin-top: 8px; }
        .row { display:flex; align-items:center; gap:8px; }
    </style>
</head>
<body>
    <div class="row">
        <span>depth 0.05</span>
        <input id="depthSlider" type="range" min="0.05" max="20" step="0.1" value="10" />
        <span>3</span>
    </div>

    <canvas id="gl-canvas" width="512" height="512"></canvas>

    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec4 aPosition;
        attribute vec4 aColor;
        varying vec4 vColor;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;

        void main() {
            vColor = aColor;
            gl_Position = uProjectionMatrix * uModelViewMatrix * aPosition;
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        varying vec4 vColor;
        void main() {
            gl_FragColor = vColor;
        }
    </script>

    <!-- Main JavaScript -->
    <script>
    
    let gl;
    let modelViewMatrixLoc, projectionMatrixLoc;
    let numPositions = 0;
    
    // Camera (spherical) and view volume
    let radius = 2.2, theta = 0.8, phi = 0.9;
    const at = vec3(0.0, 0.0, 0.0);
    let up = vec3(0.0, 1.0, 0.0);
    let left = -2.0, right = 2.0, bottom = -2.0, ytop = 2.0, near = -10.0, far = 10.0;

    // Buffers
    let positionBuffer, colorBuffer;

    // --- Geometry: Colored cube (12 triangles) ---
    // 8 cube vertices
    const vertices = [
        vec4(-0.5, -0.5,  0.5, 1.0),  // 0 front-bottom-left
        vec4( 0.5, -0.5,  0.5, 1.0),  // 1 front-bottom-right
        vec4( 0.5,  0.5,  0.5, 1.0),  // 2 front-top-right
        vec4(-0.5,  0.5,  0.5, 1.0),  // 3 front-top-left
        vec4(-0.5, -0.5, -0.5, 1.0),  // 4 back-bottom-left
        vec4( 0.5, -0.5, -0.5, 1.0),  // 5 back-bottom-right
        vec4( 0.5,  0.5, -0.5, 1.0),  // 6 back-top-right
        vec4(-0.5,  0.5, -0.5, 1.0),  // 7 back-top-left
    ];

    // Per-vertex colors
    const baseColors = [
        vec4(1.0, 0.0, 0.0, 1.0), // red
        vec4(0.0, 1.0, 0.0, 1.0), // green
        vec4(0.0, 0.0, 1.0, 1.0), // blue
        vec4(1.0, 1.0, 0.0, 1.0), // yellow
        vec4(1.0, 0.0, 1.0, 1.0), // magenta
        vec4(0.0, 1.0, 1.0, 1.0), // cyan
        vec4(1.0, 0.5, 0.0, 1.0), // orange
        vec4(0.7, 0.7, 0.7, 1.0), // gray
    ];

    const positions = [];
    const colors = [];

    // Push two triangles for a quad
    function quad(a, b, c, d, colorIndex) {
        const col = baseColors[colorIndex % baseColors.length];
        const tri = [a, b, c, a, c, d];
        tri.forEach(i => {
            positions.push(vertices[i]);
            colors.push(col);
        });
    }

    // Faces: +Z (front), +X (right), -Z (back), -X (left), +Y (top), -Y (bottom)
    function buildCube() {
        quad(0, 1, 2, 3, 0); // front
        quad(1, 5, 6, 2, 1); // right
        quad(5, 4, 7, 6, 2); // back
        quad(4, 0, 3, 7, 3); // left
        quad(3, 2, 6, 7, 4); // top
        quad(4, 5, 1, 0, 5); // bottom
        numPositions = positions.length; // vec4s
    }

    // --- Init ---
    window.onload = function init() {
        const canvas = document.getElementById("gl-canvas");
        gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (!gl) { alert("WebGL Not available"); return; }

        // Viewport & clear
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.93, 0.93, 0.95, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);

        // Program
        const program = initShaders(gl, "vertex-shader", "fragment-shader");
        gl.useProgram(program);

        // Build geometry
        buildCube();

        // Position buffer
        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(positions), gl.STATIC_DRAW);
        const aPosition = gl.getAttribLocation(program, "aPosition");
        gl.vertexAttribPointer(aPosition, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aPosition);

        // Color buffer
        colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, flatten(colors), gl.STATIC_DRAW);
        const aColor = gl.getAttribLocation(program, "aColor");
        gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(aColor);

        // Uniform locations
        modelViewMatrixLoc = gl.getUniformLocation(program, "uModelViewMatrix");
        projectionMatrixLoc = gl.getUniformLocation(program, "uProjectionMatrix");

        // Depth slider (live)
        const depthSlider = document.getElementById("depthSlider");
        depthSlider.addEventListener("input", (e) => {
            const v = parseFloat(e.target.value);
            far = v * 0.5;
            near = -v * 0.5;
        });

        // Mouse drag to orbit camera
        attachOrbitControls(canvas);

        requestAnimationFrame(render);
    };

    // --- Orbit controls (drag to rotate) --- 
    function attachOrbitControls(canvas) {
        let dragging = false, lastX = 0, lastY = 0;
        canvas.addEventListener("mousedown", (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
        window.addEventListener("mouseup", () => { dragging = false; });
        window.addEventListener("mousemove", (e) => {
            if (!dragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            lastX = e.clientX; lastY = e.clientY;
            // Adjust angles
            phi += dx * 0.005;
            theta = Math.min(Math.max(theta - dy * 0.005, 0.05), Math.PI - 0.05);

            phi = (phi + dx * 0.005) % (2 * Math.PI);
            if (phi < 0) phi += 2 * Math.PI;

            const EPS = 0.001;
            theta = Math.min(Math.max(theta - dy * 0.005, EPS), Math.PI - EPS);
            up = (theta > Math/PI / 2) ? vec3(0, -1, 0) : vec3(0, 1, 0);
        });
    }

    canvas.addEventListener("wheel", (e) => {
        const k = Math.exp(-e.deltaY * 0.001);
        left *= k; right *= k;
        bottom *= k; ytop *= k;
        e.preventDefault();
    }, { passive: false });

    // --- Render Loop ---
    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        // Camera position from spherical coordinates
        const eye = vec3(
            radius * Math.sin(theta) * Math.cos(phi),
            radius * Math.sin(theta) * Math.sin(phi),
            radius * Math.cos(theta)
        );

        // View & projection
        const modelViewMatrix = lookAt(eye, at, up);
        const projectionMatrix = ortho(left, right, bottom, ytop, near, far);

        // Upload uniforms
        gl.uniformMatrix4fv(modelViewMatrixLoc, false, flatten(modelViewMatrix));
        gl.uniformMatrix4fv(projectionMatrixLoc, false, flatten(projectionMatrix));

        // Draw the cube
        gl.drawArrays(gl.TRIANGLES, 0, numPositions);

        requestAnimationFrame(render);
    }
    </script>
</body>
</html>